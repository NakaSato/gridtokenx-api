@startuml ANCHOR_ARCHITECTURE_OVERVIEW
!theme plain
title GridTokenX Anchor Programs - High-Level Architecture

' Define components
package "Solana Blockchain" {
  
  package "Anchor Programs (On-Chain)" {
    component [Registry Program\nBxvy5Y...] as Registry #LightGreen
    component [Energy Token Program\n6LgvcJ...] as Token #LightBlue
    component [Oracle Program\n2Jqh9J...] as Oracle #Yellow
    component [Trading Program\nHzmt59...] as Trading #Orange
    component [Governance Program\n83V1DX...] as Governance #Pink
  }
  
  database "Solana Ledger" as Ledger {
    storage "Program Accounts (PDAs)" as PDAs
    storage "User Accounts" as Users
    storage "SPL Token Accounts" as Tokens
  }
}

package "Off-Chain Services" {
  component [API Gateway\n(Rust)] as API #LightGray
  component [Smart Meters\n(IoT)] as Meters #Cyan
  component [AMI System] as AMI #Cyan
}

' Relationships
API --> Oracle : Submit readings
API --> Trading : Create orders
API --> Token : Mint tokens
API --> Registry : Register users

Meters --> AMI : Report energy data
AMI --> API : Aggregate readings

Oracle --> Registry : Update meter data (CPI)
Token --> Registry : Settle balance (CPI)
Trading --> Token : Transfer tokens (CPI)
Trading --> Registry : Validate users (CPI)
Governance --> Registry : Issue ERCs (CPI)

Registry --> PDAs : Store state
Token --> PDAs : Store state
Oracle --> PDAs : Store state
Trading --> PDAs : Store state
Governance --> PDAs : Store state

Registry --> Users : User accounts
Token --> Tokens : Token accounts

note right of Oracle
  Only API Gateway
  can submit data
end note

note right of Governance
  Only REC Authority
  can issue ERCs
end note

note bottom of Registry
  Central source of truth
  for users & meters
end note

@enduml

@startuml ANCHOR_PROGRAM_RELATIONSHIPS
!theme plain
title Anchor Programs - Detailed Relationships & Data Flow

' Program components with their key functions
package "Registry Program" as RP {
  [register_user()] as RegUser
  [register_meter()] as RegMeter
  [update_meter_reading()] as UpdateReading
  [settle_meter_balance()] as Settle
  [get_unsettled_balance()] as GetUnsettled
  
  database "State" as RegState {
    [Registry]
    [UserAccount]
    [MeterAccount]
  }
}

package "Energy Token Program" as ETP {
  [initialize_token()] as InitToken
  [mint_grid_tokens()] as MintTokens
  [transfer_tokens()] as Transfer
  [burn_tokens()] as Burn
  
  database "State" as TokenState {
    [TokenInfo]
    [Mint (SPL)]
  }
}

package "Oracle Program" as OP {
  [initialize()] as InitOracle
  [submit_meter_reading()] as SubmitReading
  [trigger_market_clearing()] as TriggerClearing
  [update_oracle_status()] as UpdateStatus
  
  database "State" as OracleState {
    [OracleData]
  }
}

package "Trading Program" as TP {
  [initialize_market()] as InitMarket
  [create_sell_order()] as CreateSell
  [create_buy_order()] as CreateBuy
  [match_orders()] as MatchOrders
  [cancel_order()] as CancelOrder
  
  database "State" as TradingState {
    [Market]
    [Order]
    [TradeRecord]
  }
}

package "Governance Program" as GP {
  [initialize_poa()] as InitPoa
  [issue_erc()] as IssueErc
  [validate_erc_for_trading()] as ValidateErc
  [emergency_pause()] as Pause
  [emergency_unpause()] as Unpause
  
  database "State" as GovState {
    [PoAConfig]
    [ErcCertificate]
  }
}

' Data flow arrows
SubmitReading --> UpdateReading : CPI\nMeter data
MintTokens --> Settle : CPI\nGet tokens to mint
CreateSell --> Transfer : CPI\nEscrow tokens
CreateBuy --> Transfer : CPI\nEscrow tokens
MatchOrders --> Transfer : CPI\nSettle trade
IssueErc -right-> RegState : Read\nMeterAccount

' External interactions
cloud "API Gateway" as APIGateway #LightGray
actor "User/Prosumer" as User

APIGateway --> SubmitReading : Only authorized
APIGateway --> TriggerClearing : Only authorized
User --> RegUser : Self-register
User --> RegMeter : Register meter
User --> MintTokens : Claim tokens
User --> CreateSell : Create order
User --> CreateBuy : Create order

' Authority flows
actor "REC Authority" as REC #Pink
actor "Admin" as Admin #Gray

REC --> IssueErc : Issue certificates
REC --> ValidateErc : Validate for trading
REC --> Pause : Emergency control
REC --> Unpause : Emergency control
Admin --> UpdateStatus : Configure oracle
Admin --> InitPoa : Initialize governance

note right of MintTokens
  Prevents double-minting
  via settled_net_generation
end note

note right of IssueErc
  Prevents double-claiming
  via claimed_erc_generation
end note

note bottom of SubmitReading
  Only API Gateway can submit
  meter readings to Oracle
end note

@enduml

@startuml ANCHOR_ACCOUNT_STRUCTURE
!theme plain
title Anchor Programs - Account Structure & PDAs

package "Registry Program" {
  class Registry <<PDA: ["registry"]>> {
    + authority: Pubkey
    + user_count: u64
    + meter_count: u64
    + created_at: i64
  }
  
  class UserAccount <<PDA: ["user", authority]>> {
    + authority: Pubkey
    + user_type: UserType
    + location: String[100]
    + status: UserStatus
    + registered_at: i64
    + meter_count: u32
    + created_at: i64
  }
  
  class MeterAccount <<PDA: ["meter", meter_id]>> {
    + meter_id: String[50]
    + owner: Pubkey
    + meter_type: MeterType
    + status: MeterStatus
    + registered_at: i64
    + last_reading_at: i64
    + total_generation: u64
    + total_consumption: u64
    + settled_net_generation: u64
    + claimed_erc_generation: u64
  }
  
  enum UserType {
    Prosumer
    Consumer
  }
  
  enum UserStatus {
    Active
    Suspended
    Inactive
  }
  
  enum MeterType {
    Solar
    Wind
    Battery
    Grid
  }
  
  enum MeterStatus {
    Active
    Inactive
    Maintenance
  }
}

package "Energy Token Program" {
  class TokenInfo <<PDA: ["token_info"]>> {
    + authority: Pubkey
    + mint: Pubkey
    + total_supply: u64
    + created_at: i64
  }
  
  class "SPL Token Mint" as Mint {
    + mint_authority: Pubkey
    + supply: u64
    + decimals: u8
    + is_initialized: bool
  }
  
  class "SPL Token Account" as TokenAccount {
    + mint: Pubkey
    + owner: Pubkey
    + amount: u64
    + delegate: Option<Pubkey>
    + state: AccountState
  }
}

package "Oracle Program" {
  class OracleData <<PDA: ["oracle_data"]>> {
    + authority: Pubkey
    + api_gateway: Pubkey
    + total_readings: u64
    + last_reading_timestamp: i64
    + last_clearing: i64
    + active: bool
    + created_at: i64
  }
}

package "Trading Program" {
  class Market <<PDA: ["market"]>> {
    + authority: Pubkey
    + active_orders: u64
    + total_volume: u64
    + total_trades: u64
    + created_at: i64
    + clearing_enabled: bool
    + market_fee_bps: u16
  }
  
  class Order <<PDA: ["order", order_id]>> {
    + seller: Pubkey
    + buyer: Pubkey
    + amount: u64
    + filled_amount: u64
    + price_per_kwh: u64
    + order_type: OrderType
    + status: OrderStatus
    + created_at: i64
    + expires_at: i64
  }
  
  class TradeRecord <<PDA: ["trade", trade_id]>> {
    + sell_order: Pubkey
    + buy_order: Pubkey
    + seller: Pubkey
    + buyer: Pubkey
    + amount: u64
    + price_per_kwh: u64
    + total_value: u64
    + fee_amount: u64
    + executed_at: i64
  }
  
  enum OrderType {
    Sell
    Buy
  }
  
  enum OrderStatus {
    Active
    PartiallyFilled
    Completed
    Cancelled
    Expired
  }
}

package "Governance Program" {
  class PoAConfig <<PDA: ["poa_config"]>> {
    + authority: Pubkey
    + authority_name: String[64]
    + contact_info: String[128]
    + version: u8
    + emergency_paused: bool
    + emergency_timestamp: Option<i64>
    + emergency_reason: Option<String[128]>
    + maintenance_mode: bool
    + erc_validation_enabled: bool
    + min_energy_amount: u64
    + max_erc_amount: u64
    + erc_validity_period: i64
    + total_ercs_issued: u64
    + total_ercs_validated: u64
    + total_ercs_revoked: u64
    + total_energy_certified: u64
    + created_at: i64
    + last_updated: i64
    + last_erc_issued_at: Option<i64>
  }
  
  class ErcCertificate <<PDA: ["erc_certificate", cert_id]>> {
    + certificate_id: String[64]
    + authority: Pubkey
    + energy_amount: u64
    + renewable_source: String[64]
    + validation_data: String[256]
    + issued_at: i64
    + expires_at: Option<i64>
    + status: ErcStatus
    + validated_for_trading: bool
    + trading_validated_at: Option<i64>
  }
  
  enum ErcStatus {
    Valid
    Expired
    Revoked
    Pending
  }
}

' Relationships
Registry "1" -- "0..*" UserAccount : manages
UserAccount "1" -- "0..*" MeterAccount : owns
TokenInfo "1" -- "1" Mint : references
UserAccount "1" -- "0..*" TokenAccount : owns
Market "1" -- "0..*" Order : contains
Order "2" -- "1" TradeRecord : matched
PoAConfig "1" -- "0..*" ErcCertificate : issues
MeterAccount "1" -- "0..*" ErcCertificate : certifies energy from

note top of MeterAccount
  **Double-Spend Prevention:**
  settled_net_generation: Tracks minted GRID tokens
  claimed_erc_generation: Tracks issued ERCs
end note

note top of TokenInfo
  Controls mint authority
  via PDA with seeds
end note

note top of PoAConfig
  Single authority model
  for REC certification
end note

@enduml

@startuml ANCHOR_SEQUENCE_USER_REGISTRATION
!theme plain
title Sequence: User & Meter Registration

actor "Prosumer" as User
participant "API Gateway" as API
participant "Registry Program" as Registry
database "Solana Ledger" as Ledger

== User Registration ==
User -> API: POST /api/users/register\n{user_type: "Prosumer", location: "Bangkok"}
activate API

API -> Registry: register_user(\n  user_type: Prosumer,\n  location: "Bangkok"\n)
activate Registry

Registry -> Ledger: Create UserAccount PDA\nseeds: ["user", user_pubkey]
activate Ledger
Ledger --> Registry: PDA created
deactivate Ledger

Registry -> Registry: Initialize UserAccount:\n- authority = signer\n- user_type = Prosumer\n- location = "Bangkok"\n- status = Active\n- registered_at = timestamp

Registry -> Ledger: Update Registry:\nuser_count += 1
activate Ledger
Ledger --> Registry: Updated
deactivate Ledger

Registry -> Ledger: emit!(UserRegistered{...})
activate Ledger
Ledger --> Registry: Event emitted
deactivate Ledger

Registry --> API: Success:\nuser_account_pubkey
deactivate Registry

API --> User: {success: true,\nuser_account: "..."}
deactivate API

== Meter Registration ==
User -> API: POST /api/meters/register\n{meter_id: "METER-001", type: "Solar"}
activate API

API -> Registry: register_meter(\n  meter_id: "METER-001",\n  meter_type: Solar\n)
activate Registry

Registry -> Ledger: Load UserAccount
activate Ledger
Ledger --> Registry: UserAccount data
deactivate Ledger

Registry -> Registry: Verify user.authority == signer
alt Authorization failed
  Registry --> API: Error: UnauthorizedUser
  API --> User: Error: Unauthorized
else Authorized
  Registry -> Ledger: Create MeterAccount PDA\nseeds: ["meter", "METER-001"]
  activate Ledger
  Ledger --> Registry: PDA created
  deactivate Ledger
  
  Registry -> Registry: Initialize MeterAccount:\n- meter_id = "METER-001"\n- owner = user_pubkey\n- meter_type = Solar\n- status = Active\n- total_generation = 0\n- total_consumption = 0\n- settled_net_generation = 0\n- claimed_erc_generation = 0
  
  Registry -> Ledger: Update UserAccount:\nmeter_count += 1
  activate Ledger
  Ledger --> Registry: Updated
  deactivate Ledger
  
  Registry -> Ledger: Update Registry:\nmeter_count += 1
  activate Ledger
  Ledger --> Registry: Updated
  deactivate Ledger
  
  Registry -> Ledger: emit!(MeterRegistered{...})
  activate Ledger
  Ledger --> Registry: Event emitted
  deactivate Ledger
  
  Registry --> API: Success:\nmeter_account_pubkey
  deactivate Registry
  
  API --> User: {success: true,\nmeter_account: "..."}
  deactivate API
end

@enduml

@startuml ANCHOR_SEQUENCE_TOKEN_MINTING
!theme plain
title Sequence: Energy Generation & GRID Token Minting

actor "Smart Meter" as Meter
participant "AMI System" as AMI
participant "API Gateway" as API
participant "Oracle Program" as Oracle
participant "Registry Program" as Registry
actor "Prosumer" as User
participant "Energy Token\nProgram" as Token
participant "SPL Token\nProgram" as SPL
database "Solana Ledger" as Ledger

== Phase 1: Energy Data Collection ==
Meter -> AMI: Report:\ngeneration: 5000Wh\nconsumption: 2000Wh
activate AMI

AMI -> AMI: Aggregate readings
AMI -> API: POST /api/oracle/meter-reading\n{meter_id, generation: 5000,\nconsumption: 2000}
activate API

API -> Oracle: submit_meter_reading(\n  meter_id: "METER-001",\n  produced: 5000,\n  consumed: 2000,\n  timestamp: now\n)
activate Oracle

Oracle -> Oracle: Verify:\n- signer == api_gateway\n- oracle_data.active == true

Oracle -> Oracle: Update statistics:\n- total_readings += 1\n- last_reading_timestamp = now

Oracle -> Registry: CPI: update_meter_reading(\n  meter_id,\n  5000, 2000, timestamp\n)
activate Registry

Registry -> Ledger: Load MeterAccount
activate Ledger
Ledger --> Registry: MeterAccount
deactivate Ledger

Registry -> Registry: Update meter:\n- total_generation += 5000\n  (now: 5000Wh)\n- total_consumption += 2000\n  (now: 2000Wh)\n- last_reading_at = timestamp

Registry -> Ledger: Save MeterAccount
activate Ledger
Ledger --> Registry: Saved
deactivate Ledger

Registry -> Ledger: emit!(MeterReadingUpdated{...})
activate Ledger
Ledger --> Registry: Event emitted
deactivate Ledger

Registry --> Oracle: Success
deactivate Registry

Oracle -> Ledger: emit!(MeterReadingSubmitted{...})
activate Ledger
Ledger --> Oracle: Event emitted
deactivate Ledger

Oracle --> API: Success
deactivate Oracle

API --> AMI: {success: true}
deactivate API
deactivate AMI

== Phase 2: Token Minting (User-Initiated) ==
User -> API: POST /api/tokens/mint\n{meter_id: "METER-001"}
activate API

API -> Token: mint_grid_tokens(ctx)
activate Token

Token -> Registry: CPI: settle_meter_balance(ctx)
activate Registry

Registry -> Ledger: Load MeterAccount
activate Ledger
Ledger --> Registry: MeterAccount:\n- total_generation: 5000\n- total_consumption: 2000\n- settled_net_generation: 0
deactivate Ledger

Registry -> Registry: Calculate:\ncurrent_net = 5000 - 2000 = 3000Wh\nalready_settled = 0Wh\ntokens_to_mint = 3000 - 0 = 3000

alt No unsettled balance
  Registry --> Token: Error: NoUnsettledBalance
  Token --> API: Error
  API --> User: Error: Nothing to mint
else Has unsettled balance
  Registry -> Registry: Update:\nsettled_net_generation = 3000
  
  Registry -> Ledger: Save MeterAccount
  activate Ledger
  Ledger --> Registry: Saved
  deactivate Ledger
  
  Registry -> Ledger: emit!(MeterBalanceSettled{\n  tokens_to_mint: 3000\n})
  activate Ledger
  Ledger --> Registry: Event emitted
  deactivate Ledger
  
  Registry --> Token: Return: 3000 tokens
  deactivate Registry
  
  Token -> Token: Prepare PDA signer:\nseeds: ["token_info"]
  
  Token -> SPL: CPI: mint_to(\n  amount: 3000,\n  to: user_token_account,\n  authority: token_info_pda\n)
  activate SPL
  
  SPL -> Ledger: Mint 3000 tokens
  activate Ledger
  Ledger --> SPL: Minted
  deactivate Ledger
  
  SPL --> Token: Success
  deactivate SPL
  
  Token -> Token: Update TokenInfo:\ntotal_supply += 3000
  
  Token -> Ledger: Save TokenInfo
  activate Ledger
  Ledger --> Token: Saved
  deactivate Ledger
  
  Token -> Ledger: emit!(GridTokensMinted{\n  meter_owner,\n  amount: 3000\n})
  activate Ledger
  Ledger --> Token: Event emitted
  deactivate Ledger
  
  Token --> API: Success: 3000 tokens minted
  deactivate Token
  
  API --> User: {success: true,\nminted_amount: 3000}
  deactivate API
end

note right of Registry
  **Double-Mint Prevention:**
  settled_net_generation tracks
  what's already been tokenized
end note

@enduml

@startuml ANCHOR_SEQUENCE_P2P_TRADING
!theme plain
title Sequence: P2P Energy Trading

actor "Prosumer A\n(Seller)" as Seller
actor "Consumer B\n(Buyer)" as Buyer
participant "API Gateway" as API
participant "Trading Program" as Trading
participant "Energy Token\nProgram" as Token
participant "Registry Program" as Registry
database "Solana Ledger" as Ledger

== Step 1: Create Sell Order ==
Seller -> API: POST /api/trading/sell\n{amount: 2000Wh, price: 0.15 GRID/Wh}
activate API

API -> Trading: create_sell_order(\n  energy_amount: 2000,\n  price_per_kwh: 0.15\n)
activate Trading

Trading -> Ledger: Create Order PDA\nseeds: ["order", order_id]
activate Ledger
Ledger --> Trading: PDA created
deactivate Ledger

Trading -> Token: CPI: transfer(\n  from: seller_token_account,\n  to: escrow_account,\n  amount: 300 GRID\n)
activate Token
Token -> Ledger: Lock 300 GRID in escrow
activate Ledger
Ledger --> Token: Locked
deactivate Ledger
Token --> Trading: Success
deactivate Token

Trading -> Trading: Initialize Order:\n- seller = seller_pubkey\n- amount = 2000Wh\n- price_per_kwh = 0.15\n- order_type = Sell\n- status = Active

Trading -> Ledger: Update Market:\nactive_orders += 1
activate Ledger
Ledger --> Trading: Updated
deactivate Ledger

Trading -> Ledger: emit!(SellOrderCreated{...})
activate Ledger
Ledger --> Trading: Event emitted
deactivate Ledger

Trading --> API: sell_order_pubkey
deactivate Trading

API --> Seller: {success: true,\norder_id: "..."}
deactivate API

== Step 2: Create Buy Order ==
Buyer -> API: POST /api/trading/buy\n{amount: 1500Wh, max_price: 0.16 GRID/Wh}
activate API

API -> Trading: create_buy_order(\n  energy_amount: 1500,\n  max_price_per_kwh: 0.16\n)
activate Trading

Trading -> Ledger: Create Order PDA\nseeds: ["order", order_id]
activate Ledger
Ledger --> Trading: PDA created
deactivate Ledger

Trading -> Token: CPI: transfer(\n  from: buyer_token_account,\n  to: escrow_account,\n  amount: 240 GRID\n)
activate Token
Token -> Ledger: Lock 240 GRID in escrow\n(1500 * 0.16)
activate Ledger
Ledger --> Token: Locked
deactivate Ledger
Token --> Trading: Success
deactivate Token

Trading -> Trading: Initialize Order:\n- buyer = buyer_pubkey\n- amount = 1500Wh\n- price_per_kwh = 0.16\n- order_type = Buy\n- status = Active

Trading -> Ledger: Update Market:\nactive_orders += 1
activate Ledger
Ledger --> Trading: Updated
deactivate Ledger

Trading -> Ledger: emit!(BuyOrderCreated{...})
activate Ledger
Ledger --> Trading: Event emitted
deactivate Ledger

Trading --> API: buy_order_pubkey
deactivate Trading

API --> Buyer: {success: true,\norder_id: "..."}
deactivate API

== Step 3: Order Matching ==
note over Trading
  Triggered by matching engine
  (auto or manual)
end note

API -> Trading: match_orders(\n  sell_order,\n  buy_order\n)
activate Trading

Trading -> Ledger: Load both orders
activate Ledger
Ledger --> Trading: Orders data
deactivate Ledger

Trading -> Trading: Matching logic:\n- Check: buy_price (0.16) >= sell_price (0.15) ✓\n- match_amount = min(2000, 1500) = 1500Wh\n- agreed_price = 0.15 GRID/Wh\n- total_value = 1500 * 0.15 = 225 GRID\n- platform_fee = 225 * 0.0025 = 0.5625 GRID\n- seller_receives = 225 - 0.5625 = 224.4375 GRID

Trading -> Trading: Verify:\n- Both orders Active\n- Sufficient escrow

alt Match conditions not met
  Trading --> API: Error: PriceMismatch
else Match successful
  
  Trading -> Token: CPI: transfer(\n  from: escrow,\n  to: seller_token_account,\n  amount: 224.4375 GRID\n)
  activate Token
  Token -> Ledger: Transfer to seller
  activate Ledger
  Ledger --> Token: Transferred
  deactivate Ledger
  Token --> Trading: Success
  deactivate Token
  
  Trading -> Token: CPI: transfer(\n  from: escrow,\n  to: platform_account,\n  amount: 0.5625 GRID\n)
  activate Token
  Token -> Ledger: Transfer fee
  activate Ledger
  Ledger --> Token: Transferred
  deactivate Ledger
  Token --> Trading: Success
  deactivate Token
  
  Trading -> Token: CPI: transfer(\n  from: escrow,\n  to: buyer_token_account,\n  amount: 15 GRID (excess)\n)
  activate Token
  note right: Buyer locked 240 GRID,\nonly 225 needed,\nreturn 15 GRID
  Token -> Ledger: Return excess
  activate Ledger
  Ledger --> Token: Transferred
  deactivate Ledger
  Token --> Trading: Success
  deactivate Token
  
  Trading -> Trading: Update sell_order:\n- filled_amount = 1500Wh\n- remaining = 500Wh\n- status = PartiallyFilled
  
  Trading -> Trading: Update buy_order:\n- filled_amount = 1500Wh\n- status = Completed
  
  Trading -> Ledger: Create TradeRecord PDA:\n- amount: 1500Wh\n- price: 0.15\n- total_value: 225 GRID\n- fee_amount: 0.5625 GRID
  activate Ledger
  Ledger --> Trading: Created
  deactivate Ledger
  
  Trading -> Ledger: Update Market:\n- total_volume += 225\n- total_trades += 1\n- active_orders -= 1
  activate Ledger
  Ledger --> Trading: Updated
  deactivate Ledger
  
  Trading -> Ledger: emit!(OrderMatched{...})
  activate Ledger
  Ledger --> Trading: Event emitted
  deactivate Ledger
  
  Trading --> API: Trade successful
  deactivate Trading
  
  API --> Seller: Notification:\n"Sold 1500Wh for 224.44 GRID"
  API --> Buyer: Notification:\n"Bought 1500Wh for 225 GRID"
end

@enduml

@startuml ANCHOR_SEQUENCE_ERC_CERTIFICATION
!theme plain
title Sequence: ERC (Energy Renewable Certificate) Issuance

actor "Prosumer" as User
participant "API Gateway" as API
actor "REC Authority" as REC
participant "Governance\nProgram" as Gov
participant "Registry\nProgram" as Registry
database "Solana Ledger" as Ledger

== Prerequisite: Energy Generated ==
note over Registry
  MeterAccount state:
  - total_generation: 10,000Wh (solar)
  - total_consumption: 1,000Wh
  - claimed_erc_generation: 0Wh
  - settled_net_generation: 9,000Wh (already minted)
end note

== Step 1: ERC Issuance Request ==
User -> API: POST /api/governance/erc/issue\n{\n  meter_id: "METER-001",\n  energy_amount: 5000Wh,\n  renewable_source: "Solar"\n}
activate API

API -> REC: Forward request for approval
activate REC

REC -> REC: Manual verification:\n- Verify meter readings\n- Verify renewable source\n- Verify compliance

alt Verification failed
  REC --> API: Reject request
  API --> User: {success: false,\nreason: "Verification failed"}
else Verification successful
  
  REC -> Gov: issue_erc(\n  certificate_id: "ERC-2025-11-07-001",\n  energy_amount: 5000,\n  renewable_source: "Solar",\n  validation_data: "REC-CERT-2025-001"\n)
  activate Gov
  
  Gov -> Ledger: Load PoAConfig
  activate Ledger
  Ledger --> Gov: PoAConfig
  deactivate Ledger
  
  Gov -> Gov: Validate:\n1. poa_config.is_operational()\n   - emergency_paused = false ✓\n   - maintenance_mode = false ✓\n2. poa_config.can_issue_erc()\n   - erc_validation_enabled = true ✓\n3. signer == authority\n   - REC authority signature ✓\n4. energy_amount checks:\n   - amount >= min_energy_amount ✓\n   - amount <= max_erc_amount ✓
  
  Gov -> Registry: Load MeterAccount\n(Read-only)
  activate Registry
  
  Registry -> Ledger: Get MeterAccount data
  activate Ledger
  Ledger --> Registry: MeterAccount:\n- total_generation: 10,000Wh\n- claimed_erc_generation: 0Wh
  deactivate Ledger
  
  Registry --> Gov: MeterAccount data
  deactivate Registry
  
  Gov -> Gov: Double-claim prevention:\navailable = total_gen - claimed_erc\n         = 10,000 - 0 = 10,000Wh\nrequire!(5000 <= 10,000) ✓
  
  alt Insufficient available energy
    Gov --> REC: Error: InsufficientAvailableEnergy
    REC --> API: Error
    API --> User: Error: Already claimed
  else Sufficient energy
    
    Gov -> Ledger: Create ErcCertificate PDA\nseeds: ["erc_certificate", cert_id]
    activate Ledger
    Ledger --> Gov: PDA created
    deactivate Ledger
    
    Gov -> Gov: Initialize ErcCertificate:\n- certificate_id = "ERC-2025-11-07-001"\n- authority = REC_pubkey\n- energy_amount = 5000Wh\n- renewable_source = "Solar"\n- validation_data = "REC-CERT-2025-001"\n- issued_at = current_timestamp\n- expires_at = issued_at + validity_period\n- status = Valid\n- validated_for_trading = false
    
    Gov -> Ledger: Save ErcCertificate
    activate Ledger
    Ledger --> Gov: Saved
    deactivate Ledger
    
    Gov -> Registry: Update MeterAccount:\nclaimed_erc_generation += 5000
    activate Registry
    
    Registry -> Ledger: Load & update MeterAccount
    activate Ledger
    Ledger --> Registry: Updated:\nclaimed_erc_generation = 5000Wh
    deactivate Ledger
    
    Registry --> Gov: Success
    deactivate Registry
    
    Gov -> Gov: Update PoAConfig:\n- total_ercs_issued += 1\n- total_energy_certified += 5000\n- last_erc_issued_at = now
    
    Gov -> Ledger: Save PoAConfig
    activate Ledger
    Ledger --> Gov: Saved
    deactivate Ledger
    
    Gov -> Ledger: emit!(ErcIssued{\n  certificate_id,\n  energy_amount: 5000,\n  renewable_source: "Solar"\n})
    activate Ledger
    Ledger --> Gov: Event emitted
    deactivate Ledger
    
    Gov --> REC: ERC issued:\ncertificate_pubkey
    deactivate Gov
    
    REC --> API: {success: true,\ncertificate_id: "ERC-2025-11-07-001"}
    deactivate REC
    
    API --> User: {success: true,\nerc_certificate: {...}}
    deactivate API
  end
end

== Step 2: Validate ERC for Trading (Optional) ==
note over User
  User wants to trade
  the ERC certificate
end note

User -> API: POST /api/governance/erc/validate\n{certificate_id: "ERC-2025-11-07-001"}
activate API

API -> REC: Request validation
activate REC

REC -> Gov: validate_erc_for_trading(ctx)
activate Gov

Gov -> Ledger: Load ErcCertificate
activate Ledger
Ledger --> Gov: ErcCertificate data
deactivate Ledger

Gov -> Gov: Validate:\n- status == Valid ✓\n- not expired ✓\n- authority signature ✓

alt Validation failed
  Gov --> REC: Error: CertificateExpired
  REC --> API: Error
  API --> User: Error: Cannot validate
else Validation successful
  
  Gov -> Gov: Update ErcCertificate:\n- validated_for_trading = true\n- trading_validated_at = now
  
  Gov -> Ledger: Save ErcCertificate
  activate Ledger
  Ledger --> Gov: Saved
  deactivate Ledger
  
  Gov -> Gov: Update PoAConfig:\ntotal_ercs_validated += 1
  
  Gov -> Ledger: emit!(ErcValidatedForTrading{...})
  activate Ledger
  Ledger --> Gov: Event emitted
  deactivate Ledger
  
  Gov --> REC: Validation successful
  deactivate Gov
  
  REC --> API: {success: true}
  deactivate REC
  
  API --> User: {success: true,\nvalidated_for_trading: true}
  deactivate API
end

note right of Registry
  **Double-Claim Prevention:**
  After issuance:
  - total_generation: 10,000Wh
  - claimed_erc_generation: 5,000Wh
  - Available for new ERC: 5,000Wh
  
  If prosumer generates 3,000Wh more:
  - total_generation: 13,000Wh
  - claimed_erc_generation: 5,000Wh
  - Available for new ERC: 8,000Wh ✓
end note

@enduml

@startuml ANCHOR_CPI_PATTERNS
!theme plain
title Cross-Program Invocation (CPI) Patterns

package "Energy Token Program" {
  [mint_grid_tokens()] as Mint
}

package "Registry Program" {
  [settle_meter_balance()] as Settle
  [MeterAccount] as Meter
}

package "Oracle Program" {
  [submit_meter_reading()] as Submit
}

package "SPL Token Program" {
  [mint_to()] as SPLMint
  [transfer()] as SPLTransfer
}

package "Trading Program" {
  [match_orders()] as Match
}

== CPI Pattern 1: Energy Token → Registry (Settlement) ==
actor "User" as User1
User1 -> Mint : Call mint_grid_tokens()
activate Mint

Mint -> Mint : 1. Validate user owns meter
Mint -> Settle : 2. CPI invoke:\nsettle_meter_balance()
activate Settle

Settle -> Meter : 3. Read meter data
activate Meter
Meter --> Settle : current_net_gen,\nsettled_net_gen
deactivate Meter

Settle -> Settle : 4. Calculate:\ntokens = current_net - settled

Settle -> Meter : 5. Update:\nsettled_net_gen = current_net
activate Meter
Meter --> Settle : Updated
deactivate Meter

Settle --> Mint : 6. Return tokens_to_mint
deactivate Settle

Mint -> Mint : 7. Prepare PDA signer\nseeds: ["token_info"]

Mint -> SPLMint : 8. CPI invoke with signer:\nmint_to(amount)
activate SPLMint
SPLMint --> Mint : Tokens minted
deactivate SPLMint

Mint -> Mint : 9. Update total_supply
Mint -> Mint : 10. Emit event

Mint --> User1 : Success
deactivate Mint

note right of Mint
  **CPI Security:**
  - User must be meter owner
  - Registry validates meter state
  - PDA signing prevents unauthorized minting
end note

== CPI Pattern 2: Oracle → Registry (Meter Update) ==
actor "API Gateway" as API
API -> Submit : Call submit_meter_reading()
activate Submit

Submit -> Submit : 1. Verify signer == api_gateway
Submit -> Submit : 2. Verify oracle.active == true

Submit -> Settle : 3. CPI invoke:\nupdate_meter_reading()
activate Settle

Settle -> Meter : 4. Load MeterAccount
activate Meter
Meter --> Settle : Meter data
deactivate Meter

Settle -> Meter : 5. Update:\n- total_generation += produced\n- total_consumption += consumed\n- last_reading_at = timestamp
activate Meter
Meter --> Settle : Updated
deactivate Meter

Settle --> Submit : Success
deactivate Settle

Submit -> Submit : 6. Update oracle stats
Submit -> Submit : 7. Emit event

Submit --> API : Success
deactivate Submit

note right of Submit
  **CPI Security:**
  - Only API Gateway can call Oracle
  - Oracle must be active
  - Meter data validated by Registry
end note

== CPI Pattern 3: Trading → Token (Settlement) ==
actor "Matching Engine" as Engine
Engine -> Match : Call match_orders()
activate Match

Match -> Match : 1. Validate price match
Match -> Match : 2. Calculate amounts & fees

Match -> SPLTransfer : 3. CPI: Transfer to seller
activate SPLTransfer
SPLTransfer --> Match : Transferred
deactivate SPLTransfer

Match -> SPLTransfer : 4. CPI: Transfer fee to platform
activate SPLTransfer
SPLTransfer --> Match : Transferred
deactivate SPLTransfer

Match -> SPLTransfer : 5. CPI: Return excess to buyer
activate SPLTransfer
SPLTransfer --> Match : Transferred
deactivate SPLTransfer

Match -> Match : 6. Update order states
Match -> Match : 7. Create TradeRecord
Match -> Match : 8. Update market stats
Match -> Match : 9. Emit event

Match --> Engine : Trade settled
deactivate Match

note right of Match
  **CPI Security:**
  - Escrow accounts prevent double-spend
  - Atomic settlement (all or nothing)
  - Order state updates prevent replay
end note

@enduml

@startuml ANCHOR_SECURITY_MODEL
!theme plain
title Anchor Programs - Security Model (6 Layers)

' Use simple sequence diagram format to avoid Graphviz dependency
participant "Layer 1:\nProgram Authority" as L1 #LightCoral
participant "Layer 2:\nPDA Security" as L2 #LightBlue
participant "Layer 3:\nInstruction Validation" as L3 #LightGreen
participant "Layer 4:\nDouble-Spend Prevention" as L4 #LightYellow
participant "Layer 5:\nCPI Security" as L5 #LightPink
participant "Layer 6:\nEvent Auditing" as L6 #LightGray

L1 -> L2 : Initialize Programs\n& PDAs
activate L2

L2 -> L3 : Validate Instructions\n& Accounts
activate L3

L3 -> L4 : Prevent Double-Spending\n& Double-Claiming
activate L4

L4 -> L5 : Secure Cross-Program\nInvocations
activate L5

L5 -> L6 : Emit Events\n& Audit Logs
activate L6

note over L1
  **Layer 1: Authority Hierarchy**
  • System Admin: Deploy/upgrade programs
  • REC Authority: Issue ERCs, emergency controls
  • API Gateway: Submit meter readings
  • Users: Self-service operations
end note

note over L2
  **Layer 2: PDA Security**
  • Registry PDAs: ["registry"], ["user", authority], ["meter", meter_id]
  • Token PDAs: ["token_info"]
  • Governance PDAs: ["poa_config"], ["erc_certificate", cert_id]
  • Oracle PDAs: ["oracle_data"]
  • Trading PDAs: ["market"], ["order", order_id], ["trade", trade_id]
  
  **Protection:**
  • Deterministic addresses
  • Program-owned only
  • Cannot be created externally
end note

note over L3
  **Layer 3: Instruction Validation**
  • Authority Checks: Verify signer permissions
  • State Validation: Check operational status
  • Amount Validation: Min/max constraints
  • Ownership Verification: User owns resources
  
  **Example:**
  require!(signer == authority)
  require!(oracle_data.active)
  require!(amount >= min_amount)
end note

note over L4
  **Layer 4: Double-Spend Prevention**
  • Token Minting Protection:
    - settled_net_generation tracker
    - Prevents re-minting same energy
  
  • ERC Claiming Protection:
    - claimed_erc_generation tracker
    - Prevents re-certifying same energy
  
  • Trading Escrow Protection:
    - Atomic multi-transfer settlement
    - Order state prevents replay
end note

note over L5
  **Layer 5: CPI Security**
  • CPI Validation: Verify calling program ID
  • PDA Signing: Only program can sign with PDA
  • Account Validation: Ownership & mutability checks
  
  **Pattern:**
  let seeds = &[b"token_info", &[bump]];
  let signer = &[&seeds[..]];
  CpiContext::new_with_signer(program, accounts, signer)
end note

note over L6
  **Layer 6: Event Auditing**
  • Event Emission: All state changes emit events
    - UserRegistered, MeterRegistered
    - GridTokensMinted, OrderMatched
    - ErcIssued, EmergencyPauseActivated
  
  • Transaction Logs: Base64-encoded data
  • Immutable History: Blockchain guarantees
  
  **Benefits:**
  • Off-chain monitoring
  • Audit trail
  • Forensic analysis
end note

L6 --> L5 : Audit Complete
deactivate L6
L5 --> L4 : CPI Secure
deactivate L5
L4 --> L3 : No Double-Spend
deactivate L4
L3 --> L2 : Validation Passed
deactivate L3
L2 --> L1 : State Updated
deactivate L2

@enduml
